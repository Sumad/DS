---
title: "Data_Sets, Data Structures, Data Import Sources  "
author: "Sumad Singh"
date: "September 5, 2017"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
  
```{r}
# Function to return a combination of results for printing at the end of a section
print.all <-  function (...){
  temp <- list(...)
  for (i in 1:length(temp)){
    print(temp[[i]])
  }
}


```

## DATASETS, DATA TYPES IN R, SCALES OF MEASUREMENT

```{r}
# DATA SETS
# Fundamentally identifiers of a data set are 
#1. Primary Key / Case Identifier : Can be declared as rownames in R or id variables 
# (if using package like reshape)
#2. Rows / Cases are observations
#3. Columns are called variables

# DATA TYPES : A value, in a data structure can be of these types
# Basic data types :numeric, character, logical, imaginary, raw
# Add'l data types : date, factor
# Special types : NA, NaN, NULL

# SCALES OF MEASUREMENT
# Variables with nominal and ordinal scale have to be identified as factors
# Continuous scaled are identified as numeric

# DATA STRUCTURES
# vector, matrix, array - multidimensional matrix, dataframe, list

# OBJECTS 
# Any thing that can be assigned to a variables in R is an object.
# An object has a class, which helps generic functions like print() to 
# handle a wide vriety of objects, and a mode to tell how it is stored

# CLASS - can be seen using class(), usually objects are of class of one
# of the data structures - vector, data frame, list etc
 class(NA) # logical, object of NA class
 class(NaN) # numeric, object if numeric class
 class(NULL) # NULL , a separate class

```
## DATA STRUCTURES

```{r}
# VECTORS
# Some ways to initialize a vector
x <- 5:10
y <- seq_along(x)
# Initialize a charcter vector of length 10, values are blans i.e ""
z <- vector(mode = "character", length = 10)

# Create a vector of NULLs and populate it
null.vec <- rep(NULL, 6)
vec <- sapply(x, function (x) {
                   x            
})
print.all(x,y,z,vec)
```

```{r}
# MATRICES 
# Explore the function
mat <-matrix(data= vec,nrow = 3,ncol =2 ,byrow = TRUE ,
       dimnames = list(rnames = c("r1","r2","r3"), cnames = c("c1", "c2")) )
print.all(str(mat), dimnames(mat))
```

```{r}
# ARRAYS - multi dimensional matrices
# Example of three dimensional arrays
a <- array(data = 4:27, dim = c(2,3,4) ,dimnames = list(dim1 = c("a1","a2"), 
                                                        dim2= c("b1","b2", "b3"),
                                                        dim3= c("c1","c2", "c3", "c4"))) 
# array of 2*3*4 elements
print.all(a, a[1,2,3]) # element identified as a1,a2,c3
# Matrices can have same type of elements
```

```{r}
# DATA FRAMES
#  Constucting from vectors
id <- c(3,4,2,1,5)
age <- c(22,32,45,33,32)
diabetes1 <- c("Type1", "Type2", "Type1", "Type2", "Type2")
diabetes2 <- c("Type3", "Type3", "Type4", "Type4", "Type3")
pdata <- data.frame(id, age, diabetes1, diabetes2, row.names = id ,stringsAsFactors = FALSE)
# CASE IDENTIFIER CAN BE SPECIFIED IN THE ARGUMENT WHILE CREATING A DATA FRAME

## Noteworthy items
# 1. data frame() has an argument ..., which lets you specify the vectors as columns i.e
 df <- data.frame(ID = id, AGE = age , DIABETES = diabetes1)

# 2. stringsAsFactors is a true by default, one can set them globally as 
# options(stringsAsFactors = FALSE) or in the frame creation

# 3. Indexing using names - PARTIAL MATCHING , A PROBLEM
# $ INDEXING : df$DIAB #returns a vector, because partial matching is applied on column names
# when indexing with $
#pdata$diab returns NULL, you would want it to return an error!

# [] INDEXING:
#1. df[,"DIAB"] though returns an error, which is good

#2. Useful to index and make call to variable by refrence i.e
 #x <- c("ID","AGE") , df[,x] 
 # x <- c("ID","AG") , df[,x] will not work and throw an error
print.all(df$DIAB, pdata$diab)  # df[,"DIAB"] , df[,c("ID","AG")] throw error

# lESSON :You have to be careful of these aspects when building data pipelines, using []
# seems to be helpful
```

```{r}
# DATAFRAMES CONTINUED
# CROSS TABS FROM DATA FRAMES 
tbl <- table(pdata$age, pdata$diabetes1)

# HOW TO AVOID USE OF COLUMN NAMES : CREATING ENCLOSURES
# ATTACH(), DETACH(), WITH()
# attach puts the name of the data frame/s in R's search path, so you can use the 
# column names freely, detach does the opposite

attach(mtcars)
str(mtcars)
tbl2 <- table(cyl,gear)
detach()

# Limitation : MASKING OF NAMES OF OBJECTS IN WORKSPACE, IF NAMES ARE SAME
# THIS COMES UP EVEN WHEN FUNCTION NAMES ARE SAME ACROSS PACKAGES
# IN THAT EVENT, ONE HAS TO DO AN EXCLUSIVE CALL TO FUNCTION WITH PACKAGE NAME
# AS <PACKAGE> :: <FUNCTION NAME>
cyl <- c(2,3,4)
print.all(attach(mtcars) , cyl) # 
detach(mtcars)

# WITH() AND <<-
with(mtcars, table(cyl,gear))
# With creates an environmnt enclosure, any variables or functions defined in the 
# enclosure are valid in the enclosure only
# << i.e GLOBAL ASSIGNMENT CAN BE USED WITH WITH() TO USE VARIABLES CREATED OUTSIDE THE ENCLOSURE
 with(mtcars,{
   tbl3 <<- table(cyl, gear)
 })
tbl3
```

```{r}
# FACTORS
# VARIABLES IN A DATA FRAME THAT ARE ON SCALE ORDINAL OR NOMINAL NEED TO BE DECLARED AS FACTORS,
# TO ENSURE PROPER TREATMENT IN STATISTICAL ANALYSIS, AS WELL AS IN PLOTTING
# Use of Function factor()
id <- c(3,4,2,1,5)
age <- c(22,32,45,33,32)
diabetes <- c("Type1", "Type2", "Type1", "Type2", "Type2")
status <- c("poor", "improved", "poor", "improved", "excellent")
pdata1 <- data.frame(id, age, diabetes, status, row.names = id ,stringsAsFactors = FALSE)
pdata2 <- pdata1
pdata3 <- pdata1
pdata4 <- pdata1

# factor is stored in R as a vector of integers, mapped to the levels
# arguments to a factor let you specify if it is for an ordinal or a nominal scale variable, as 
# well as order of the levels in the ordinal variable

## ORDERED FACTOR, SPECIFIED LEVELS, NEW LABLES, INTEGERS ARE ASSIGNED IN THE ORDER THE LEVELS ARE
## SPECIFIED
pdata2$status <- factor(x = pdata2$status ,
                        levels = c("poor", "improved", "excellent") ,
                        labels = c("P", "I", "E"),
                        ordered = TRUE )
## UNORDERED FACTOR, INTEGERS ARE ASSIGNED IN THE ORDER LEVELS ARE SPECIFIED
pdata3$status <- factor(x = pdata3$status ,
                        levels = c("poor", "improved", "excellent") )
## UNORDERED FACTOR, LEVELS ARE NOT SPECIFIED, SO INTEGERS ARE ASSIGNED
## IN ALPHABETIC ORDER
pdata4$status <- factor(x = pdata4$status, 
                        labels = c("P", "I", "E"))
                        

print.all(str(pdata1), str(pdata2), str(pdata3), str(pdata4), summary(pdata4))

```

```{r}
#LISTS
hospital <- c("A","B","C","D")
ls <- list(hp = hospital, hp1 = pdata1, hp2 = pdata2, hp3 = pdata3, hp4 = pdata4)
print.all(ls, names(ls))

```

## DATA INPUT FROM DIFFERENT SOURCES

|INPUT|PACKAGE|KEY FUNCTIONS|FURTHER READING/COMMENTS|
|---|---|---|---|
|DELIMITED FILES||||
|XLS||||
|RDBMS||||
|XML||||
|WEB SCRAPING||||
|HDFS - HIVE TABLES, PARQUET FILES||||
|JSON||||
|SPSS, SAS||||


